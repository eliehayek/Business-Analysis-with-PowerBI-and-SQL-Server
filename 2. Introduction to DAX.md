# Introduction to DAX

### Understanding DAX calculations
```sql
'Sales'[Quantity]              -- the reference of the quantity column in the Sales table

Sales[Quantity] * 2            -- This is a column reference

[Sales Amount] * 2             -- This is a measure reference

-- or // for single ligne comment

/* multiline comment */

```

### DAX data types
```sql
DAX data type          Power BI Data Type          Correspondent conventional SQL Data type

Integer                Whole Number                Integer/ INT
Decimal                Decimal Number              Floating point/ DOUBLE
Currency               Fixed Decimal Number        Currency/ MONEY
DateTime               DateTime, Date, Time        Date/ DATETIME
Boolean                True/False                  Boolean/ BIT
String                 Text                        String/ NVARCHAR(MAX)
Binary                 Binary                      Blob/ VARBINARY(MAX)
```

- Operator Overloading
```sql
Sales[OrderDatePlusOneWeek] = Sales[Order Date] + 7   -- The result is a date adding 7 days
```
n addition to operator overloading, DAX automatically converts strings into numbers and numbers into strings whenever 
required by the operator. For example, if we use the & operator, which concatenates strings, DAX converts its arguments into strings. 
The following formula returns “54” as a string:
```sql
= 5 & 4
```
On the other hand, this formula returns an integer result with the value of 9:
```sql
= "5" + "4"
```
The resulting value depends on the operator and not on the source columns, which are converted following the requirements 
of the operator. Moreover, not all the operators follow this behavior. For example, comparison operators cannot compare strings 
with numbers. Consequently, you can add one number with a string, but you cannot compare a number with a string.
To be more explicit, the previous example should be written like this:
```sql
= VALUE ( "5" ) + VALUE ( "4" )
```

- Integer:

DAX has only one Integer data type that can store a 64-bit value. All the internal calculations between integer values in DAX 
also use a 64-bit value.
- Decimal:

A Decimal number is always stored as a double-precision floating-point value. Do not confuse this DAX data type with the decimal 
and numeric data type of Transact-SQL. The corresponding data type of a DAX decimal number in SQL is Float.
- Currency:

The Currency data type, also known as Fixed Decimal Number in Power BI, stores a fixed decimal number. It can represent four decimal 
points and is internally stored as a 64-bit integer value divided by 10,000. Summing or subtracting Currency data types always ignores 
decimals beyond the fourth decimal point, whereas multiplication and division produce a floating-point value, thus increasing the 
precision of the result. In general, if we need more accuracy than the four digits provided, we must use a Decimal data type.
The default format of the Currency data type includes the currency symbol. We can also apply the currency formatting to Integer 
and decimal numbers, and we can use a format without the currency symbol for a Currency data type.

- DateTime:

DAX stores dates as a DateTime data type. This format uses a floating-point number internally, wherein the integer corresponds 
to the number of days since December 30, 1899, and the decimal part identifies the fraction of the day. Hours, minutes, and seconds 
are converted to decimal fractions of a day. Thus, the following expression returns the current date plus one day (exactly 24 hours):
```sql
= TODAY () + 1
```
If you need to take only the date part of a DateTime, always remember to use TRUNC to get rid of the decimal part.

- Boolean:

The Boolean data type is used to express logical conditions. For example, a calculated column defined by the following 
expression is of Boolean type:
```sql
 = Sales[Unit Price] > Sales[Unit Cost]
 ```
 You will also see Boolean data types as numbers where TRUE equals 1 and FALSE equals 0. This notation sometimes proves 
 useful for sorting purposes because TRUE > FALSE.
 
 - String:

Every string in DAX is stored as a Unicode string, where each character is stored in 16 bits. By default, the comparison 
between strings is not case sensitive, so the two strings “Power BI” and “POWER BI” are considered equal.

- Variant:

The Variant data type is used for expressions that might return different data types, depending on the conditions. 
For example, the following statement can return either an integer or a string, so it returns a variant type:
```sql
 IF ( [measure] > 0, 1, "N/A" )
 ```
The Variant data type cannot be used as a data type for a column in a regular table. A DAX measure, and in general, 
a DAX expression can be Variant.

- Binary:

The Binary data type is used in the data model to store images or other nonstructured types of information. It is not 
available in DAX. It was mainly used by Power View, but it might not be available in other tools such as Power BI.

### DAX Operators

```sql
Operator Type           Symbol       Use                            Example
-------------------------------------------------------------------------------------------------
Parenthesis             ()           Precedence order and           (5 + 2) * 3
                                     grouping of arguments  
-------------------------------------------------------------------------------------------------
Arithmetic              +            Addition                        4 + 2
                        -            Substraction/ negation          5 - 3
                        *            Multiplication                  4 * 2
                        /            Division                        4/2
-------------------------------------------------------------------------------------------------
Comparison              =            Equal to                        [CountryRegion] = "USA"
                        <>           Not equal to                    [CountryRegion] <> "USA"
                        >            Greater than                    [Quantity] > 0
                        >=           Greater than or equal to        [Quantity] >= 100
                        <            Less than                       [Quantity] < 0
                        <=           Less than or equal to           [Quantity] < = 100
--------------------------------------------------------------------------------------------------
Text concatenation      &            Concatenation of strings        "Value is" & [Amount]
--------------------------------------------------------------------------------------------------
Logical                 &&           AND condition                   [CountryRegion] = “USA” && [Quantity]>0
                        ||           OR condition                    [CountryRegion] = “USA” || [Quantity] > 0
                        IN           Inclusion of an element         [CountryRegion] IN {“USA”, “Canada”}
                        NOT          Boolean negation                 NOT [Quantity] > 0
--------------------------------------------------------------------------------------------------
 ```
 
Moreover, the logical operators are also available as DAX functions:
```sql
AND ( [CountryRegion] = "USA", [Quantity] > 0 )
OR ( [CountryRegion] = "USA", [Quantity] > 0 )
 ```
These examples are equivalent, respectively, to the following:
```sql
[CountryRegion] = "USA" && [Quantity] > 0
[CountryRegion] = "USA" || [Quantity] > 0
  ```
Using functions instead of operators for Boolean logic becomes helpful when writing complex conditions. In fact, when it comes to formatting large sections of code, functions are much easier to format and to read than operators are. However, a major drawback of functions is that we can pass in only two parameters at a time. Therefore, we must nest functions if we have more than two conditions to evaluate.

### Table constructor

In DAX we can define anonymous tables directly in the code. If the table has a single column, the syntax requires only a list of values—one for each row—delimited by curly braces. We can delimit multiple rows by parentheses, which are optional if the table is made of a single column. The two following definitions, for example, are equivalent:
```sql
{ "Red", "Blue", "White" }
{ ( "Red" ), ( "Blue" ), ( "White" ) }
  ```
If the table has multiple columns, parentheses are mandatory. Every column should have the same data type throughout all its rows; otherwise, DAX will automatically convert the column to a data type that can accommodate all the data types provided in different rows for the same column.
```sql
{
    ( "A", 10, 1.5, DATE ( 2017, 1, 1 ), CURRENCY ( 199.99 ), TRUE ),
    ( "B", 20, 2.5, DATE ( 2017, 1, 2 ), CURRENCY ( 249.99 ), FALSE ),
    ( "C", 30, 3.5, DATE ( 2017, 1, 3 ), CURRENCY ( 299.99 ), FALSE )
}
```
The table constructor is commonly used with the IN operator. For example, the following are possible, valid syntaxes in a DAX predicate:
```sql
'Product'[Color] IN { "Red", "Blue", "White" }
( 'Date'[Year], 'Date'[MonthNumber] ) IN { ( 2017, 12 ), ( 2018, 1 ) }
```
We can rewrite it using the IN operator with a table constructor that has a single row, as in the following example:
```sql
( 'Date'[Year], 'Date'[MonthNumber] ) IN { ( 2007, 12 ) }
```
### Conditional statements

In DAX we can write a conditional expression using the IF function. For example, we can write an expression returning MULTI or SINGLE depending on the quantity value being greater than one or not, respectively.
```sql
IF (
    Sales[Quantity] > 1,
    "MULTI",
    "SINGLE"
)
```
The IF function has three parameters, but only the first two are mandatory. The third is optional, and it defaults to BLANK. Consider the following code:
```sql
IF (
    Sales[Quantity] > 1,
    Sales[Quantity]
)
```
It corresponds to the following explicit version:
```sql
IF (
    Sales[Quantity] > 1,
    Sales[Quantity],
    BLANK ()
)
```

### Understanding calculated columns and measures

You need to learn one of the most important concepts in DAX: the difference between calculated columns and measures.

#### Calculated columns

Depending on the tool you are using, you can create a calculated column in different ways. Indeed, the concept remains the same: a calculated column is a new column added to your model, but instead of being loaded from a data source, it is created by resorting to a DAX formula.

#### Measures

Calculated columns are useful, but you can define calculations in a DAX model in another way. Whenever you do not want to compute values for each row but rather want to aggregate values from many rows in a table, you will find these calculations useful; they are called measures. For example, you can define a few calculated columns in the Sales table to compute the gross margin amount:
```sql
Sales[SalesAmount] = Sales[Quantity] * Sales[Net Price]
Sales[TotalCost] = Sales[Quantity] * Sales[Unit Cost]
Sales[GrossMargin] = Sales[SalesAmount] – Sales[TotalCost]
```
Measures and calculated columns both use DAX expressions; the difference is the context of evaluation. A measure is evaluated in the context of a visual element or in the context of a DAX query. However, a calculated column is computed at the row level of the table it belongs to. The context of the visual element depends on user selections in the report or on the format of the DAX query. Therefore, when using SUM(Sales[SalesAmount]) in a measure, we mean the sum of all the rows that are aggregated under a visualization. However, when we use Sales[SalesAmount] in a calculated column, we mean the value of the SalesAmount column in the current row.
A measure needs to be defined in a table. This is one of the requirements of the DAX language. However, the measure does not really belong to the table. Indeed, we can move a measure from one table to another table without losing its functionality.

### Choosing between calculated columns and measures

Now that you have seen the difference between calculated columns and measures, it is useful to discuss when to use one over the other. Sometimes either is an option, but in most situations, the computation requirements determine the choice.

As a developer, you must define a calculated column whenever you want to do the following:

- Place the calculated results in a slicer or see results in rows or columns in a matrix or in a pivot table (as opposed to the Values area), or use the calculated column as a filter condition in a DAX query.

- Define an expression that is strictly bound to the current row. For example, Price * Quantity cannot work on an average or on a sum of those two columns.

- Categorize text or numbers. For example, a range of values for a measure, a range of ages of customers, such as 0–18, 18–25, and so on. These categories are often used as filters or to slice and dice values.

However, it is mandatory to define a measure whenever one wants to display calculation values that reflect user selections, and the values need to be presented as aggregates in a report, for example:

- To calculate the profit percentage of a report selection

- To calculate ratios of a product compared to all products but keep the filter both by year and by region

We can express many calculations both with calculated columns and with measures, although we need to use different DAX expressions for each. For example, one can define the GrossMargin as a calculated column:
```sql
Sales[GrossMargin] = Sales[SalesAmount] - Sales[TotalProductCost]
```
However, it can also be defined as a measure:
```sql
GrossMargin := SUM ( Sales[SalesAmount] ) - SUM ( Sales[TotalProductCost] )
```

We suggest you use a measure in this case because, being evaluated at query time, it does not consume memory and disk space. As a rule, whenever you can express a calculation both ways, measures are the preferred way to go. You should limit the use of calculated columns to the few cases where they are strictly needed. Users with Excel experience typically prefer calculated columns over measures because calculated columns closely resemble the way of performing calculations in Excel. Nevertheless, the best way to compute a value in DAX is through a measure.

### Introducing variables

When writing a DAX expression, one can avoid repeating the same expression and greatly enhance the code readability by using variables. For example, look at the following expression:
```sql
VAR TotalSales = SUM ( Sales[SalesAmount] )
VAR TotalCosts = SUM ( Sales[TotalProductCost] )
VAR GrossMargin = TotalSales - TotalCosts
RETURN
    GrossMargin / TotalSales
```

Variables are defined with the VAR keyword. After you define a variable, you need to provide a RETURN section that defines the result value of the expression. One can define many variables, and the variables are local to the expression in which they are defined.

A variable defined in an expression cannot be used outside the expression itself. There is no such thing as a global variable definition. This means that you cannot define variables used through the whole DAX code of the model.


## Introducing aggregators and iterators

Almost every data model needs to operate on aggregated data. DAX offers a set of functions that aggregate the values of a column in a table and return a single value. We call this group of functions aggregation functions. For example, the following measure calculates the sum of all the numbers in the SalesAmount column of the Sales table:

```sql
Sales := SUM ( Sales[SalesAmount] )
```

SUM aggregates all the rows of the table if it is used in a calculated column. Whenever it is used in a measure, it considers only the rows that are being filtered by slicers, rows, columns, and filter conditions in the report.
There are many aggregation functions (SUM, AVERAGE, MIN, MAX, and STDEV), and their behavior changes only in the way they aggregate values: SUM adds values, whereas MIN returns the minimum value. Nearly all these functions operate only on numeric values or on dates. Only MIN and MAX can operate on text values also. Moreover, DAX never considers empty cells when it performs the aggregation, and this behavior is different from their counterpart in Excel

Iterators always accept at least two parameters: the first is a table that they scan; the second is typically an expression that is evaluated for each row of the table. After they have completed scanning the table and evaluating the expression row by row, iterators aggregate the partial results according to their semantics.
For example, if we compute the number of days needed to deliver an order in a calculated column called DaysToDeliver and build a report on top of that:
```sql
 Sales[DaysToDeliver] = INT ( Sales[Delivery Date] - Sales[Order Date] )
 ```
 
 ## Using common DAX functions
 
 Now that you have seen the fundamentals of DAX and how to handle error conditions, what follows is a brief tour through the most commonly used functions and expressions of DAX.
 

COUNT operates on any data type, apart from Boolean.
COUNTA operates on any type of column.
COUNTBLANK returns the number of empty cells (blanks or empty strings) in a column. COUNTROWS returns the number of rows in a table.
DISTINCTCOUNT returns the number of distinct values of a column, blank value included if present.
DISTINCTCOUNTNOBLANK returns the number of distinct values of a column, no blank value included.

## Logical functions

